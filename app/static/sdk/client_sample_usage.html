<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>STT + TTS + AgentClient integration demo</title>
	<script src="../socket.io.min.js"></script>
	<style>
		body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
		fieldset { border: 1px solid #ddd; border-radius: 8px; padding: 12px; margin-bottom: 12px; }
		label { display: inline-block; min-width: 150px; }
		input[type="text"] { width: 420px; }
		button { padding: 6px 10px; margin-right: 8px; }
		#out, #log { white-space: pre-wrap; background: #f6f6f6; padding: 12px; border-radius: 8px; min-height: 80px; }
		#out { min-height: 120px; }
		.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
		#textInput { width: 100%; min-height: 90px; box-sizing: border-box; font: inherit; padding: 8px; }
	</style>
</head>
<body>
	<h1>STT + TTS + AgentClient integration demo</h1>

	<fieldset>
		<legend>Connections</legend>
		<div>
			<label for="agentUrl">Agent server URL</label>
			<input id="agentUrl" type="text" value="" />
			<button id="connectAgent">Connect Agent</button>
			<span id="agentState" class="mono"></span>
		</div>
		<div style="margin-top:8px;">
			<label for="sttUrl">STT URL</label>
			<input id="sttUrl" type="text" value="http://localhost:2700" />
			<button id="connectSTT">Subscribe STT</button>
			<span id="sttState" class="mono"></span>
		</div>
		<div style="margin-top:8px;">
			<label for="ttsUrl">TTS URL</label>
			<input id="ttsUrl" type="text" value="http://localhost:7700" />
			<button id="connectTTSBtn">Connect TTS</button>
			<span id="ttsState" class="mono"></span>
		</div>
	</fieldset>

	<fieldset>
		<legend>Mic</legend>
		<div>
			<label for="clientId">clientId</label>
			<input id="clientId" type="text" />
			<button id="newClientId">New</button>
		</div>
		<div style="margin-top:8px;">
			<label for="threadId">threadId</label>
			<input id="threadId" type="text" />
			<button id="newThreadId">New</button>
		</div>
		<div style="margin-top:8px;">
			<label for="agentName">agent</label>
			<select id="agentName">
				<option value="succint">succint</option>
				<option value="general">general</option>
				<option value="topic">topic</option>
				<option value="router">router</option>
			</select>
		</div>
		<div style="margin-top:8px;">
			<button id="startMic" disabled>Start mic → STT</button>
			<button id="stopMic" disabled>Stop mic</button>
			<button id="cancelRun" disabled>Cancel current run</button>
		</div>
	</fieldset>

	<fieldset>
		<legend>Text chat</legend>
		<p style="margin:0 0 8px;">Type a message to send directly to the agent server. <span class="mono">(Ctrl/Cmd+Enter to send, Shift+Enter for newline)</span></p>
		<textarea id="textInput" placeholder="Type your message..."></textarea><br />
		<button id="sendText" disabled>Send</button>
	</fieldset>

	<p><strong>Assistant streaming reply:</strong></p>
	<pre id="out"></pre>

	<p><strong>Events log:</strong></p>
	<pre id="log" class="mono"></pre>

	<script type="module">
		//	use real tabs
		import { AgentClient } from "./agentClient.js";
		import { AudioResampler } from "./audioResampler.js";

		//	$ helpers
		const $ = (id) => document.getElementById(id);
		const agentUrlEl = $("agentUrl"), sttUrlEl = $("sttUrl"), ttsUrlEl = $("ttsUrl");
		const agentStateEl = $("agentState"), sttStateEl = $("sttState"), ttsStateEl = $("ttsState");
		const clientIdEl = $("clientId"), threadIdEl = $("threadId"), agentNameEl = $("agentName");
		const textInputEl = $("textInput"), btnSendText = $("sendText");
		const outEl = $("out"), logEl = $("log");
		const btnConnectAgent = $("connectAgent"), btnConnectSTT = $("connectSTT"), btnConnectTTS = $("connectTTSBtn");
		const btnStartMic = $("startMic"), btnStopMic = $("stopMic"), btnCancelRun = $("cancelRun");
		const btnNewClientId = $("newClientId"), btnNewThreadId = $("newThreadId");

		//	defaults
		agentUrlEl.value = location.origin;
		const newUUID = () => (crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));
		clientIdEl.value = newUUID();
		threadIdEl.value = newUUID();

		//	log (kept concise)
		const log = (...a) => { logEl.textContent += a.join(" ") + "\n"; logEl.scrollTop = logEl.scrollHeight; };

		//	Agent client
		const client = new AgentClient({ url: agentUrlEl.value });

		btnConnectAgent.addEventListener("click", async () => {
			try {
				client.socket?.disconnect();
				await client.connect({ onReconnect: (n) => { agentStateEl.textContent = `reconnected (#${n})`; } });
				agentStateEl.textContent = "connected";
				btnSendText.disabled = false;

				// server-initiated runs (from STT)
				client.onStream({
					onStarted: () => { btnCancelRun.disabled = false; },
					onText: (full) => { outEl.textContent = full; },
					onDone: () => { btnCancelRun.disabled = true; },
					onError: () => { btnCancelRun.disabled = true; }
				});

				log("[agent] connected");
			} catch (e) {
				agentStateEl.textContent = "error";
				log("[agent][error]", e?.message || String(e));
			}
		});

		// ----- STT subscribe + mic pipeline -----
		let sttSubscribed = false;
		let sttSocket = null;     // direct socket for audio_data
		let micAudioCtx = null, micSource = null, micWorklet = null, micResampler = null, micStream = null;

		async function ensureSttSocket() {
			if (sttSocket?.connected) return sttSocket;
			sttSocket = io(sttUrlEl.value.trim(), { transports: ["websocket"] });
			await new Promise((res, rej) => { sttSocket.once("connect", res); sttSocket.once("connect_error", rej); });
			log("[stt] connected for audio_data");
			return sttSocket;
		}

		btnConnectSTT.addEventListener("click", async () => {
			try {
				const agent = agentNameEl.value;
				let threadId = threadIdEl.value.trim() || newUUID();
				threadIdEl.value = threadId;

				await client.sttSubscribe({
					sttUrl: sttUrlEl.value.trim(),
					clientId: clientIdEl.value.trim(),
					agent,
					threadId
				});

				sttStateEl.textContent = "subscribed via agent_server";
				sttSubscribed = true;
				btnStartMic.disabled = false;
				log("[stt] subscribed");
			} catch (e) {
				sttStateEl.textContent = "error";
				log("[stt][error]", e?.message || String(e));
			}
		});

		agentNameEl.addEventListener("change", async () => {
			if (!sttSubscribed) return;
			try {
				await client.sttUnsubscribe({ sttUrl: sttUrlEl.value.trim(), clientId: clientIdEl.value.trim() });
				await client.sttSubscribe({
					sttUrl: sttUrlEl.value.trim(),
					clientId: clientIdEl.value.trim(),
					agent: agentNameEl.value,
					threadId: threadIdEl.value.trim() || newUUID()
				});
				log("[stt] re-subscribed with agent =", agentNameEl.value);
			} catch (e) {
				log("[stt][error] re-subscribe:", e?.message || String(e));
			}
		});

		btnStartMic.addEventListener("click", async () => {
			try {
				if (!sttSubscribed) { log("[mic] subscribe STT first"); return; }
				await ensureSttSocket();

				// mic stream
				micStream = await navigator.mediaDevices.getUserMedia({
					audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: false, channelCount: 1 },
					video: false
				});

				// audio context @48k → resample to 16k
				micAudioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000, latencyHint: "interactive" });
				await micAudioCtx.audioWorklet.addModule("./recorder.worklet.js");

				micSource = micAudioCtx.createMediaStreamSource(micStream);
				micWorklet = new AudioWorkletNode(micAudioCtx, "recorder-worklet", { numberOfInputs: 1, numberOfOutputs: 0 });
				micResampler = new AudioResampler(micAudioCtx.sampleRate, 16000);

				// batch ~100ms @48k
				let batch = [];
				let batched = 0;
				const BATCH_TARGET = micAudioCtx.sampleRate / 10;

				micWorklet.port.onmessage = (e) => {
					const f32 = e.data;
					batch.push(f32);
					batched += f32.length;

					if (batched >= BATCH_TARGET) {
						const merged = new Float32Array(batched);
						let off = 0; for (const c of batch) { merged.set(c, off); off += c.length; }
						batch = []; batched = 0;

						const pcm16 = micResampler.pushFloat32(merged);
						if (pcm16?.length) {
							sttSocket.emit("audio_data", {
								clientId: clientIdEl.value.trim(),
								audioData: pcm16.buffer
							});
						}
					}
				};

				micSource.connect(micWorklet);

				btnStartMic.disabled = true;
				btnStopMic.disabled = false;
				log("[mic] started");
			} catch (e) {
				log("[mic][error]", e?.message || String(e));
			}
		});

		btnStopMic.addEventListener("click", async () => {
			try {
				if (micWorklet?.port) micWorklet.port.onmessage = null;
				try { micWorklet?.disconnect(); } catch {}
				try { micSource?.disconnect(); } catch {}
				try { await micAudioCtx?.close(); } catch {}
				try { micStream?.getTracks().forEach(t => t.stop()); } catch {}
			} finally {
				micAudioCtx = micSource = micWorklet = micResampler = micStream = null;
				btnStartMic.disabled = false;
				btnStopMic.disabled = true;
				log("[mic] stopped");
			}
		});

		btnCancelRun.addEventListener("click", () => {
			client.cancel(); // agent_server will also stop TTS
			log("[run] cancel requested");
		});

		// ----- Text chat -----
		async function sendTextNow() {
			const text = textInputEl.value.trim();
			if (!text) return;

			log("[you]", text);
			textInputEl.value = "";

			let threadId = threadIdEl.value.trim() || newUUID();
			threadIdEl.value = threadId;

			const agent = agentNameEl.value;
			outEl.textContent = "";
			btnSendText.disabled = true; btnCancelRun.disabled = false;

			try {
				await client.runText(text, { agent, threadId }, {
					onStarted: () => {},
					onText: (full) => { outEl.textContent = full; },
					onDone: () => {},
					onError: () => {}
				});
			} catch (e) {
				log("[chat][error]", e?.message || String(e));
			} finally {
				btnSendText.disabled = false; btnCancelRun.disabled = true;
			}
		}
		btnSendText.addEventListener("click", sendTextNow);
		textInputEl.addEventListener("keydown", (e) => {
			if (!e.isComposing && e.key === "Enter" && !e.shiftKey) { e.preventDefault(); if (!btnSendText.disabled) sendTextNow(); }
		});

		// ----- TTS integration -----
		let ttsSocket = null;
		let ttsSubscribed = false;
		let ttsPlayCtx = null;
		let ttsPlayQueue = Promise.resolve();

		function ensureTtsAudioContext() {
			if (!ttsPlayCtx) ttsPlayCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
			return ttsPlayCtx;
		}
		function closeTtsAudio() {
			try { ttsPlayCtx?.close(); } catch {}
			ttsPlayCtx = null; ttsPlayQueue = Promise.resolve();
		}
		async function registerTtsAudioClient(socket, mainClientId) {
			return new Promise((resolve, reject) => {
				if (!socket?.connected) return reject(new Error("TTS socket not connected"));
				socket.emit("register_audio_client", { main_client_id: mainClientId, connection_type: "browser", mode: "tts" }, () => resolve());
			});
		}
		async function connectTTS(ttsUrl, clientId) {
			const socket = io(ttsUrl, {
				path: "/socket.io",
				transports: ["websocket"],
				forceNew: true,
				query: { type: "browser", format: "binary", main_client_id: clientId }
			});
			await new Promise((res, rej) => { socket.once("connect", res); socket.once("connect_error", rej); socket.once("error", rej); });
			await registerTtsAudioClient(socket, clientId);
			ttsStateEl.textContent = "connected";
			log("[tts] connected + audio sink registered");

			socket.on("tts_audio_chunk", async (evt) => {
				const buf = evt?.audio_buffer;
				if (!buf) return;
				const actx = ensureTtsAudioContext();
				const audioBuf = await actx.decodeAudioData(buf.slice(0));
				ttsPlayQueue = ttsPlayQueue.then(() => new Promise((resolve) => {
					const src = actx.createBufferSource();
					src.buffer = audioBuf; src.connect(actx.destination); src.start();
					src.onended = resolve;
				}));
			});
			socket.on("tts_stop_immediate", () => { closeTtsAudio(); });
			socket.on("disconnect", (reason) => log("[tts][disconnect]", reason));
			return socket;
		}

		btnConnectTTS.addEventListener("click", async () => {
			try {
				const clientId = clientIdEl.value.trim();
				const ttsUrl = ttsUrlEl.value.trim();

				await client.ttsSubscribe({ clientId });
				ttsSubscribed = true;

				if (!ttsSocket?.connected) ttsSocket = await connectTTS(ttsUrl, clientId);
				else await registerTtsAudioClient(ttsSocket, clientId);

				ttsStateEl.textContent = "connected";
			} catch (e) {
				ttsStateEl.textContent = "error";
				log("[tts][error]", e?.message || String(e));
			}
		});

		// ----- clientId/threadId helpers -----
		async function rebindForNewClientId(prevId, newId) {
			// TTS (browser sink + agent_server mapping)
			if (ttsSocket?.connected && ttsSubscribed) {
				await registerTtsAudioClient(ttsSocket, newId);
				await client.ttsUnsubscribe({ clientId: prevId });
				await client.ttsSubscribe({ clientId: newId });
				log("[tts] re-bound to new clientId");
			}
			// STT (agent_server mapping)
			if (client?.socket?.connected && sttSubscribed) {
				await client.sttUnsubscribe({ sttUrl: sttUrlEl.value.trim(), clientId: prevId });
				await client.sttSubscribe({
					sttUrl: sttUrlEl.value.trim(),
					clientId: newId,
					agent: agentNameEl.value,
					threadId: threadIdEl.value.trim() || newUUID()
				});
				sttStateEl.textContent = "subscribed via agent_server";
				log("[stt] re-bound to new clientId");
			}
		}

		btnNewClientId.addEventListener("click", async () => {
			const prev = clientIdEl.value.trim();
			const curr = newUUID();
			clientIdEl.value = curr;
			try { await rebindForNewClientId(prev, curr); }
			catch (e) { log("[clientId][error] rebind:", e?.message || String(e)); }
		});
		btnNewThreadId.addEventListener("click", () => { threadIdEl.value = newUUID(); });

		// cleanup
		window.addEventListener("beforeunload", () => {
			try { ttsSocket?.disconnect(); } catch {}
			try { sttSocket?.disconnect(); } catch {}
			closeTtsAudio();
		});
	</script>
</body>
</html>
