<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>STT + TTS + AgentClient integration demo</title>
	<!-- Make io() global -->
	<script src="../socket.io.min.js"></script>
	<style>
		body {
			font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
			margin: 16px;
		}
		fieldset {
			border: 1px solid #ddd;
			border-radius: 8px;
			padding: 12px;
			margin-bottom: 12px;
		}
		label { display: inline-block; min-width: 150px; }
		input[type="text"] { width: 420px; }
		button { padding: 6px 10px; margin-right: 8px; }
		#out, #log {
			white-space: pre-wrap;
			background: #f6f6f6;
			padding: 12px;
			border-radius: 8px;
			min-height: 80px;
		}
		#out { min-height: 120px; }
		.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
		#textInput {
			width: 100%;
			min-height: 90px;
			box-sizing: border-box;
			font: inherit;
			padding: 8px;
		}
	</style>
</head>
<body>
	<h1>STT + TTS + AgentClient integration demo</h1>

	<fieldset>
		<legend>Connections</legend>
		<div>
			<label for="agentUrl">Agent server URL</label>
			<input id="agentUrl" type="text" value="" />
			<button id="connectAgent">Connect Agent</button>
			<span id="agentState" class="mono"></span>
		</div>
		<div style="margin-top:8px;">
			<label for="sttUrl">STT URL</label>
			<input id="sttUrl" type="text" value="http://localhost:2700" />
			<button id="connectSTT">Subscribe STT</button>
			<span id="sttState" class="mono"></span>
		</div>
		<div style="margin-top:8px;">
			<label for="ttsUrl">TTS URL</label>
			<input id="ttsUrl" type="text" value="http://localhost:7700" />
			<button id="connectTTSBtn">Connect TTS</button>
			<span id="ttsState" class="mono"></span>
		</div>
	</fieldset>

	<fieldset>
		<legend>Mic</legend>
		<div>
			<label for="clientId">clientId</label>
			<input id="clientId" type="text" />
			<button id="newClientId">New</button>
		</div>
		<div style="margin-top:8px;">
			<label for="threadId">threadId</label>
			<input id="threadId" type="text" />
			<button id="newThreadId">New</button>
		</div>
		<div style="margin-top:8px;">
			<label for="agentName">agent</label>
			<select id="agentName">
				<option value="general">general</option>
				<option value="topic">topic</option>
				<option value="router">router</option>
			</select>
		</div>
		<div style="margin-top:8px;">
			<button id="startMic" disabled>Start mic → STT</button>
			<button id="stopMic" disabled>Stop mic</button>
			<button id="cancelRun" disabled>Cancel current run</button>
		</div>
	</fieldset>

	<fieldset>
		<legend>Text chat</legend>
		<p style="margin:0 0 8px;">Type a message to send directly to the agent server. <span class="mono">(Ctrl/Cmd+Enter to send, Shift+Enter for newline)</span></p>
		<textarea id="textInput" placeholder="Type your message..."></textarea><br />
		<button id="sendText" disabled>Send</button>
	</fieldset>

	<p><strong>Assistant streaming reply:</strong></p>
	<pre id="out"></pre>

	<p><strong>Events log:</strong></p>
	<pre id="log" class="mono"></pre>

	<script type="module">
		//	use real tabs for indentation
		import { AgentClient } from "./agentClient.js";
		import { AudioResampler } from "./audioResampler.js";

		//	Elems
		const $ = (id) => document.getElementById(id);
		const agentUrlEl = $("agentUrl");
		const sttUrlEl = $("sttUrl");
		const ttsUrlEl = $("ttsUrl");
		const agentStateEl = $("agentState");
		const sttStateEl = $("sttState");
		const ttsStateEl = $("ttsState");
		const clientIdEl = $("clientId");
		const threadIdEl = $("threadId");
		const agentNameEl = $("agentName");
		const textInputEl = $("textInput");
		const btnSendText = $("sendText");
		const outEl = $("out");
		const logEl = $("log");
		const btnConnectAgent = $("connectAgent");
		const btnConnectSTT = $("connectSTT");
		const btnConnectTTS = $("connectTTSBtn");
		const btnStartMic = $("startMic");
		const btnStopMic = $("stopMic");
		const btnCancelRun = $("cancelRun");
		const btnNewClientId = $("newClientId");
		const btnNewThreadId = $("newThreadId");

		//	Default agent server URL
		agentUrlEl.value = location.origin;

		//	Log helper
		const log = (...args) => {
			const msg = args.map(a => typeof a === "string" ? a : JSON.stringify(a)).join(" ");
			logEl.textContent += msg + "\n";
			logEl.scrollTop = logEl.scrollHeight;
		};

		//	IDs
		const newUUID = () => (crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));
		clientIdEl.value = newUUID();
		threadIdEl.value = newUUID();
		btnNewClientId.addEventListener("click", async () => {
			const prev = clientIdEl.value.trim();
			clientIdEl.value = newUUID();
			const curr = clientIdEl.value.trim();
			log("[clientId] new:", curr);

			// If TTS is connected, re-register this socket as audio sink for the new clientId
			try {
				if (ttsSocket && ttsSocket.connected) {
					await registerTtsAudioClient(ttsSocket, curr);
					ttsStateEl.textContent = "connected (audio sink re-registered)";
					log("[tts] audio sink re-registered for", curr);
				}
				// Also notify agent_server about new TTS mapping (Leave/Join)
				if (client?.socket?.connected && ttsSubscribed) {
					await client.ttsUnsubscribe({ clientId: prev });
					await client.ttsSubscribe({ clientId: curr });
					log("[tts] re-subscribed via agent_server for new clientId");
				}
				// Re-subscribe STT too (so agent_server maps STT→this clientId)
				if (client?.socket?.connected && sttSubscribed) {
					await client.sttUnsubscribe({ sttUrl: sttUrlEl.value.trim(), clientId: prev });
					await client.sttSubscribe({
						sttUrl: sttUrlEl.value.trim(),
						clientId: curr,
						agent: agentNameEl.value,
						threadId: threadIdEl.value.trim() || newUUID()
					});
					sttStateEl.textContent = "subscribed via agent_server";
					log("[stt] re-subscribed with new clientId");
				}
			} catch (e) {
				log("[clientId][error] re-bind services:", e?.message || String(e));
			}
		});
		btnNewThreadId.addEventListener("click", () => { threadIdEl.value = newUUID(); });

		//	Agent client
		//	Note: if you change agentUrl then click Connect, this instance keeps the original URL.
		//	If you want to fully re-point, refresh the page (simple for the demo).
		const client = new AgentClient({ url: agentUrlEl.value });

		btnConnectAgent.addEventListener("click", async () => {
			try {
				client.socket?.disconnect();
				await client.connect({
					onReconnect: (n) => {
						agentStateEl.textContent = `reconnected (#${n})`;
						log("[agent] reconnected", n);
					}
				});
				agentStateEl.textContent = "connected";

				// Enable text chat once connected
				btnSendText.disabled = false;

				// Global stream handlers (server-initiated runs from STT)
				client.onStream({
					onStarted: (id) => { log("[run started]", id); btnCancelRun.disabled = false; },
					onText: (full) => { outEl.textContent = full; },
					onDone: () => { log("[done]"); btnCancelRun.disabled = true; },
					onError: (e) => { log("[run error]", e); btnCancelRun.disabled = true; }
				});

				// Receive transcripts from the agent_server (server is single source of truth)
				client.onTranscripts({
				onInterim: ({ text, uttId }) => {
					const id = uttId ? ` #${String(uttId).slice(0,8)}` : "";
					log(`[stt→client] interim${id}: ${text}`);
				},
				onFinal: ({ text, uttId, duration }) => {
					const id = uttId ? ` #${String(uttId).slice(0,8)}` : "";
					const dur = typeof duration === "number" ? ` (${duration.toFixed(1)}s)` : "";
					log(`[stt→client] final${id}${dur}: ${text}`);

					// (optional) mirror the user's line above the assistant stream
					outEl.textContent = `(you) ${text}\n\n` + outEl.textContent;
				}
				});

				log("[agent] connected");
			} catch (e) {
				agentStateEl.textContent = "error";
				log("[agent][error]", e?.message || String(e));
			}
		});

		//	— STT subscribe (agent_server listens to transcripts) —
		let sttSubscribed = false;

		btnConnectSTT.addEventListener("click", async () => {
			try {
				const agent = agentNameEl.value;

				let threadId = threadIdEl.value.trim();
				if (!threadId) {
					threadId = newUUID();
					threadIdEl.value = threadId;
					log("[stt] threadId was empty → generated:", threadId);
				}

				await client.sttSubscribe({
					sttUrl: sttUrlEl.value.trim(),
					clientId: clientIdEl.value.trim(),
					agent,
					threadId
				});

				sttStateEl.textContent = "subscribed via agent_server";
				log("[stt] subscribed (server-side multiplex)");
				sttSubscribed = true;

				btnStartMic.disabled = false;

			} catch (e) {
				sttStateEl.textContent = "error";
				log("[stt][error]", e?.message || String(e));
			}
		});

		// Re-subscribe STT with new agent selection (if subscribed)
		agentNameEl.addEventListener("change", async () => {
			if (sttSubscribed) {
				try {
					await client.sttUnsubscribe({
						sttUrl: sttUrlEl.value.trim(),
						clientId: clientIdEl.value.trim()
					});
					await client.sttSubscribe({
						sttUrl: sttUrlEl.value.trim(),
						clientId: clientIdEl.value.trim(),
						agent: agentNameEl.value,
						threadId: threadIdEl.value.trim() || newUUID()
					});
					log("[stt] re-subscribed with agent =", agentNameEl.value);
				} catch (e) {
					log("[stt][error] re-subscribe:", e?.message || String(e));
				}
			}
		});

		//	— Mic → STT (binary only; no transcript listener here) —
		let audioCtx = null;
		let source = null;
		let proc = null;          // AudioWorkletNode
		let sttSocket = null;     // direct Socket.IO to STT for audio_data
		let resampler = null;
		let micStream = null;

		btnStartMic.addEventListener("click", async () => {
			try {
				if (btnStartMic.disabled) {
					log("[mic] blocked: subscribe STT first so threadId is known server-side");
					return;
				}

				// ensure direct socket to STT (for audio_data)
				if (!sttSocket || !sttSocket.connected) {
					sttSocket = io(sttUrlEl.value.trim(), { transports: ["websocket"] });
					await new Promise((resolve, reject) => {
						sttSocket.once("connect", resolve);
						sttSocket.once("connect_error", reject);
					});
					log("[stt] io connected for audio_data");
				}

				// get mic
				const stream = await navigator.mediaDevices.getUserMedia({
					audio: {
						echoCancellation: true,
						noiseSuppression: true,
						autoGainControl: false,
						channelCount: 1
					},
					video: false
				});
				micStream = stream;

				// audio context @48k; we’ll resample to 16k
				audioCtx = new (window.AudioContext || window.webkitAudioContext)({
					sampleRate: 48000,
					latencyHint: "interactive"
				});

				// load worklet module (path relative to this HTML)
				await audioCtx.audioWorklet.addModule("./recorder.worklet.js");

				source = audioCtx.createMediaStreamSource(stream);

				// create the worklet (mono in, no outputs)
				const worklet = new AudioWorkletNode(audioCtx, "recorder-worklet", {
					numberOfInputs: 1,
					numberOfOutputs: 0
				});

				resampler = new AudioResampler(audioCtx.sampleRate, 16000);

				// batch around ~100ms @48k to reduce overhead
				let batch = [];
				let batchedSamples = 0;
				const BATCH_TARGET = audioCtx.sampleRate / 10;

				worklet.port.onmessage = (e) => {
					const f32 = /** @type {Float32Array} */ (e.data);
					batch.push(f32);
					batchedSamples += f32.length;

					if (batchedSamples >= BATCH_TARGET) {
						// merge chunks
						const merged = new Float32Array(batchedSamples);
						let off = 0;
						for (const c of batch) { merged.set(c, off); off += c.length; }
						batch = [];
						batchedSamples = 0;

						// resample → Int16Array @16k
						const pcm16 = resampler.pushFloat32(merged);
						if (pcm16 && pcm16.length) {
							sttSocket.emit("audio_data", {
								clientId: clientIdEl.value.trim(),
								audioData: pcm16.buffer
							});
						}
					}
				};

				source.connect(worklet);
				proc = worklet;

				btnStartMic.disabled = true;
				btnStopMic.disabled = false;
				log("[mic] started (AudioWorkletNode)");
			} catch (e) {
				log("[mic][error]", e?.message || String(e));
			}
		});

		btnStopMic.addEventListener("click", async () => {
			try {
				if (proc) {
					try { if (proc.port) proc.port.onmessage = null; } catch {}
					try { proc.disconnect(); } catch {}
				}
				if (source) { try { source.disconnect(); } catch {} }
				if (audioCtx) { try { await audioCtx.close(); } catch {} }
				if (micStream) { try { micStream.getTracks().forEach(t => t.stop()); } catch {} }
			} finally {
				audioCtx = null;
				source = null;
				proc = null;
				resampler = null;
				micStream = null;
				btnStartMic.disabled = false;
				btnStopMic.disabled = true;
				log("[mic] stopped");
			}
		});

		btnCancelRun.addEventListener("click", () => {
			client.cancel();
			log("[run] cancel requested");
		});

		// — Text send —
		async function sendTextNow() {
			const text = textInputEl.value.trim();
			if (!text) return;

			log("[you]", text);
			textInputEl.value = "";

			let threadId = threadIdEl.value.trim();
			if (!threadId) {
				threadId = newUUID();
				threadIdEl.value = threadId;
				log("[chat] threadId was empty → generated:", threadId);
			}

			const agent = agentNameEl.value;

			outEl.textContent = "";
			btnSendText.disabled = true;
			btnCancelRun.disabled = false;

			try {
				await client.runText(text, { agent, threadId }, {
					onStarted: (id) => log("[run started]", id),
					onText: (full) => { outEl.textContent = full; },
					onDone: () => { log("[done]"); },
					onError: (e) => { log("[run error]", e); }
				});
			} catch (e) {
				log("[chat][error]", e?.message || String(e));
			} finally {
				btnSendText.disabled = false;
				btnCancelRun.disabled = true;
			}
		}

		btnSendText.addEventListener("click", sendTextNow);

		// Enter sends, Shift+Enter makes a newline
		textInputEl.addEventListener("keydown", (e) => {
			if (e.isComposing) return;
			if (e.key === "Enter" && !e.shiftKey) {
				e.preventDefault();
				if (!btnSendText.disabled) {
					sendTextNow();
				}
			}
		});

		// ======== TTS integration (client socket + AgentClient JoinTTS) ========

		let ttsSocket = null;
		let ttsSubscribed = false;
		let ttsPlayCtx = null;			// AudioContext for playback
		let ttsPlayQueue = Promise.resolve();	// serialize playback

		function ensureTtsAudioContext() {
			if (!ttsPlayCtx) {
				ttsPlayCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
			}
			return ttsPlayCtx;
		}

		function closeTtsAudioContext() {
			if (ttsPlayCtx) {
				try { ttsPlayCtx.close(); } catch {}
				ttsPlayCtx = null;
			}
			ttsPlayQueue = Promise.resolve();
		}

		async function registerTtsAudioClient(socket, mainClientId) {
			return new Promise((resolve, reject) => {
				if (!socket || !socket.connected) return reject(new Error("TTS socket not connected"));
				socket.emit(
					"register_audio_client",
					{ main_client_id: mainClientId, connection_type: "browser", mode: "tts" },
					() => resolve()
				);
			});
		}

		async function connectTTS(ttsUrl, clientId) {
			// Connect as a Socket.IO browser client, binary mode, bound to main_client_id
			const socket = io(ttsUrl, {
				path: "/socket.io",
				transports: ["websocket"],
				forceNew: true,
				query: {
					type: "browser",
					format: "binary",
					main_client_id: clientId
				}
			});

			// Wait until connected (or error)
			await new Promise((resolve, reject) => {
				socket.once("connect", resolve);
				socket.once("connect_error", reject);
				socket.once("error", reject);
			});

			// Register this socket as the audio sink for clientId
			await registerTtsAudioClient(socket, clientId);
			ttsStateEl.textContent = "connected";
			log("[tts] connected + audio sink registered");

			socket.on("tts_audio_chunk", async (evt) => {
			const buf = evt?.audio_buffer;
			if (!buf) return;
			const actx = ensureTtsAudioContext();
			const audioBuf = await actx.decodeAudioData(buf.slice(0));
			ttsPlayQueue = ttsPlayQueue.then(() => {
				const src = actx.createBufferSource();
				src.buffer = audioBuf;
				src.connect(actx.destination);
				src.start();
				return new Promise(res => { src.onended = res; });
			});
			});

			socket.on("tts_stop_immediate", () => {
				closeTtsAudioContext();
				log("[tts] stop immediate");
			});

			socket.on("connect_error", (e) => {
				ttsStateEl.textContent = "error";
				log("[tts][connect_error]", e?.message || String(e));
			});
			socket.on("error", (e) => {
				ttsStateEl.textContent = "error";
				log("[tts][error]", e?.message || String(e));
			});
			socket.on("disconnect", (reason) => log("[tts][disconnect]", reason));

			return socket;
		}


		btnConnectTTS.addEventListener("click", async () => {
			try {
				const clientId = clientIdEl.value.trim();
				const ttsUrl = ttsUrlEl.value.trim();

				// 1) Tell agent_server to stream chunks to TTS for this clientId
				await client.ttsSubscribe({ clientId });
				ttsSubscribed = true;
				log("[tts] subscribed via agent_server");

				// 2) Browser: connect to TTS as audio sink (binary)
				if (!ttsSocket || !ttsSocket.connected) {
					ttsSocket = await connectTTS(ttsUrl, clientId);  // <-- now returns a ready socket
				} else {
					// Already connected → just re-register sink for current clientId
					await registerTtsAudioClient(ttsSocket, clientId);
				}

				ttsStateEl.textContent = "connected";
			} catch (e) {
				ttsStateEl.textContent = "error";
				log("[tts][error]", e?.message || String(e));
			}
		});

		// Optional: clean up TTS socket on page unload (best-effort)
		window.addEventListener("beforeunload", () => {
			try { ttsSocket?.disconnect(); } catch {}
			try { closeTtsAudioContext(); } catch {}
		});
	</script>
</body>
</html>
